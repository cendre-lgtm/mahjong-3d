<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>æ–°æ˜¥å–œæ…¶ç‰ˆï¼šå°æ—¥é›™åˆ¶ç«‹é«”éº»å°‡</title>
    <!-- Three.js Core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls for Rotation -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- TWEEN.js for smooth animation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #2d0a0a; font-family: 'Microsoft JhengHei', sans-serif; touch-action: none; user-select: none; -webkit-user-select: none; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 50; }
        .interactive { pointer-events: auto; }
        canvas { display: block; }
        
        /* ç¯€æ…¶æŒ‰éˆ•æ¨£å¼ */
        .btn-festive { 
            background: linear-gradient(135deg, #d4af37 0%, #aa8a2e 100%); 
            color: #4a0404;
            border-radius: 12px; 
            font-weight: 900; 
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            transition: all 0.1s;
            border: 2px solid #fff5d7;
            text-shadow: 0 1px 0 rgba(255,255,255,0.3);
            padding: 10px 16px;
            font-size: 1.1rem;
            min-width: 70px;
        }
        @media (min-width: 768px) {
            .btn-festive {
                padding: 14px 24px;
                font-size: 1.3rem;
                min-width: 90px;
            }
        }
        .btn-festive:active { transform: scale(0.95); }
        .btn-festive:disabled { filter: grayscale(1); opacity: 0.5; pointer-events: none; }
        
        /* äº®èµ·çš„èƒ¡ç‰ŒæŒ‰éˆ•ç‰¹æ•ˆ */
        .btn-hu-active {
            animation: pulse-gold 1.5s infinite;
            background: linear-gradient(135deg, #ff0000 0%, #990000 100%) !important;
            color: white !important;
            border-color: #ffd700 !important;
            box-shadow: 0 0 25px #ff0000 !important;
            transform: scale(1.1);
        }
        @keyframes pulse-gold {
            0% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.7); }
            70% { box-shadow: 0 0 0 15px rgba(255, 215, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0); }
        }

        .gold-text { color: #d4af37; text-shadow: 1px 1px 2px rgba(0,0,0,0.8); }
        .red-panel { background: rgba(139, 0, 0, 0.85); border: 2px solid #d4af37; box-shadow: 0 4px 20px rgba(0,0,0,0.6); }
        
        /* çµæŸæŒ‰éˆ•ç‰¹åˆ¥æ¨£å¼ */
        .btn-exit {
            background: linear-gradient(135deg, #c0392b 0%, #8e44ad 100%);
            color: white; border: 2px solid #e74c3c;
            border-radius: 50px; 
            font-weight: bold; 
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            display: flex; align-items: center; gap: 5px;
            padding: 6px 12px; font-size: 0.8rem;
        }
        @media (min-width: 768px) { .btn-exit { padding: 8px 16px; font-size: 0.9rem; } }
        .btn-exit:active { transform: scale(0.95); }

        /* é©šå–œå‹•ç•« */
        @keyframes firework {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }
        .surprise-text { animation: firework 0.5s ease-out forwards; }

        /* ç‰¹å¯«å‹•ç•« */
        .preview-anim { animation: popIn 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }
        @keyframes popIn { 0% { transform: scale(0.8); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }

        /* æ“ä½œæŒ‡å¼•æç¤º */
        .tutorial-hint { animation: pulse 2s infinite; }
        @keyframes pulse { 0% { opacity: 0.6; } 50% { opacity: 1; } 100% { opacity: 0.6; } }

        /* å³ä¸‹è§’åŠŸèƒ½æŒ‰éˆ•ç¾¤ */
        .ctrl-btn {
            background: rgba(0,0,0,0.6); border: 1px solid #d4af37;
            color: #d4af37; border-radius: 50%; 
            display: flex; align-items: center; justify-content: center;
            pointer-events: auto; cursor: pointer; margin-top: 10px;
            transition: all 0.3s;
            width: 40px; height: 40px; font-size: 20px;
        }
        @media (min-width: 768px) { .ctrl-btn { width: 50px; height: 50px; font-size: 24px; } }
        .ctrl-btn.active { background: #d4af37; color: #000; box-shadow: 0 0 10px #d4af37; }
        
        .hidden-ctrl { display: none !important; }

        /* ç‰¹å¯«é è¦½å€äº’å‹•æ¨£å¼ */
        #preview-box.interactive-preview {
            cursor: pointer;
            pointer-events: auto;
            transition: transform 0.1s ease;
        }
        #preview-box.interactive-preview:active {
            transform: scale(0.85) !important; /* é»æ“Šæ™‚ç¸®å°æ•ˆæœ */
        }
        
        /* æ‰£æ¬¾å‹•ç•« */
        @keyframes fadeUp {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-20px); }
        }
        .deduct-anim {
            position: absolute;
            color: #ff4d4d;
            font-weight: bold;
            animation: fadeUp 1s forwards;
            pointer-events: none;
        }
        
        /* åƒç‰Œé¸æ“‡æŒ‰éˆ• */
        .btn-chi-select {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            border: 2px solid #6ee7b7; color: white;
            padding: 10px 20px; border-radius: 12px; font-size: 1.5rem;
            display: flex; gap: 5px; box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        .btn-chi-select:active { transform: scale(0.95); }
    </style>
</head>
<body>

<div id="game-container"></div>

<audio id="bgm" loop>
    <source src="https://raw.githubusercontent.com/cendre-lgtm/2026/refs/heads/main/(%E6%AD%A1%E5%BF%AB)%20%E6%96%B0%E5%B9%B4%EF%BD%9C%E5%85%8D%E8%B2%BB%E8%83%8C%E6%99%AF%E9%9F%B3%E6%A8%82%E4%B8%8B%E8%BC%89%EF%BD%9C%E7%84%A1%E7%89%88%E6%AC%8A%E9%85%8D%E6%A8%82%EF%BD%9CBGM%EF%BD%9CNCS%20%E3%80%90%E8%83%A4%E6%A8%82%E9%9F%B3%E6%A8%82%E3%80%91%20(7).mp3" type="audio/mpeg">
</audio>

<!-- UI åœ–å±¤ -->
<div id="ui-layer" class="flex flex-col justify-between p-2 md:p-4 h-full">
    <div class="flex justify-between items-start interactive w-full">
        <!-- å·¦ä¸Šè§’è³‡è¨Šå€ -->
        <div class="flex flex-col gap-2 items-start max-w-[45%]">
            <button onclick="returnToMenu()" class="btn-exit">
                <span>ğŸ </span> <span class="hidden sm:inline">çµæŸç‰Œå±€</span><span class="sm:hidden">çµæŸ</span>
            </button>
            <div id="game-info" class="red-panel text-white p-2 md:p-3 rounded-xl text-xs md:text-sm backdrop-blur-md shadow-lg w-full relative">
                <div class="whitespace-nowrap flex items-center gap-2">
                    <span class="text-yellow-400">ğŸ’° ä»£å¹£:</span> 
                    <span id="credit-count" class="font-mono font-bold text-white">10000</span>
                </div>
                <div class="w-full h-[1px] bg-white/20 my-1"></div>
                <div class="whitespace-nowrap">æ¨¡å¼: <span id="mode-display" class="font-bold text-yellow-300">-</span></div>
                <div class="whitespace-nowrap">é¢¨åœˆ: <span class="text-yellow-100 font-bold">æ±é¢¨</span></div>
                <div class="whitespace-nowrap">ç‰Œæ•¸: <span id="wall-count" class="font-mono text-yellow-200">--</span></div>
            </div>
        </div>

        <!-- å³ä¸Šè§’åˆ†æ•¸æ¿ -->
        <div id="score-board" class="red-panel text-white p-2 md:p-3 rounded-xl text-xs md:text-sm text-right backdrop-blur-md shadow-lg max-w-[50%]">
            <div id="p0-ui" class="gold-text transition-all duration-300">ç©å®¶ 1: <span id="s0">25000</span></div>
            <div id="p1-ui" class="transition-all duration-300">ç©å®¶ 2: <span id="s1">25000</span></div>
            <div id="p2-ui" class="transition-all duration-300">ç©å®¶ 3: <span id="s2">25000</span></div>
            <div id="p3-ui" class="transition-all duration-300">ç©å®¶ 4: <span id="s3">25000</span></div>
        </div>
    </div>

    <!-- é¸ç‰Œ/å‡ºç‰Œ ç‰¹å¯«é è¦½å€ (ç™½åº•ï¼Œæ·±è‰²å­—) -->
    <div id="preview-overlay" class="pointer-events-none fixed inset-0 flex flex-col items-center justify-center z-30 opacity-0 transition-opacity duration-200">
        <!-- ç‰Œé¢ç‰¹å¯« (æ–°å¢é»æ“Šå‡ºç‰ŒåŠŸèƒ½) -->
        <div class="bg-white/95 p-4 md:p-6 rounded-3xl border-4 border-yellow-600 backdrop-blur-md shadow-2xl flex flex-col items-center transform scale-75 md:scale-90 mb-2 md:mb-6 interactive-preview" 
             id="preview-box" onclick="game.confirmDiscardFromPreview()">
            <div id="preview-emoji" class="text-8xl md:text-[9rem] leading-none mb-2 filter drop-shadow-[0_5px_15px_rgba(0,0,0,0.3)]">ğŸ€„</div>
            <div id="preview-text" class="text-red-800 text-xl md:text-2xl font-black tracking-widest text-center whitespace-nowrap"></div>
            <div id="preview-sub" class="text-gray-600 text-xs md:text-sm mt-1 font-bold text-center"></div>
            <div id="preview-hint" class="text-green-600 text-xs mt-2 font-bold animate-pulse hidden">(é»æ“Šæ­¤è™•å‡ºç‰Œ)</div>
        </div>

        <!-- å‹•ä½œæŒ‰éˆ•ç¾¤ -->
        <div id="action-btns" class="flex flex-wrap justify-center gap-2 md:gap-3 hidden pointer-events-auto transform scale-90 md:scale-100 max-w-[90vw]">
            <button id="btn-chi" onclick="game.handlePlayerAction('chi')" class="btn-festive bg-green-600 text-white border-green-300 shadow-[0_0_20px_rgba(34,197,94,0.6)]">åƒ</button>
            <button id="btn-pon" onclick="game.handlePlayerAction('pon')" class="btn-festive bg-blue-600 text-white border-blue-300 shadow-[0_0_20px_rgba(59,130,246,0.6)]">ç¢°</button>
            <button id="btn-kan" onclick="game.handlePlayerAction('kan')" class="btn-festive bg-purple-600 text-white border-purple-300 shadow-[0_0_20px_rgba(147,51,234,0.6)]">æ§“</button>
            <button id="btn-hu" onclick="game.handlePlayerAction('hu')" class="btn-festive !bg-red-600 !text-white !border-white !shadow-[0_0_25px_rgba(220,38,38,0.8)]">èƒ¡</button>
            <button id="btn-skip" onclick="game.handlePlayerAction('skip')" class="btn-festive !bg-gray-700 !text-gray-200 !border-gray-500">é</button>
        </div>

        <!-- åƒç‰Œé¸æ“‡ç¾¤ (ç¨ç«‹é¡¯ç¤º) -->
        <div id="chi-select-btns" class="flex flex-wrap justify-center gap-4 hidden pointer-events-auto transform scale-90 md:scale-100 max-w-[95vw]">
            <!-- å‹•æ…‹ç”Ÿæˆé¸é … -->
        </div>
    </div>

    <!-- è¨Šæ¯æç¤º -->
    <div id="msg-box" class="pointer-events-none fixed top-[20%] left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-red-600 text-yellow-300 border-2 border-yellow-400 px-6 py-3 md:px-8 md:py-4 rounded-full font-black opacity-0 transition-all shadow-2xl scale-110 z-50 whitespace-nowrap text-sm md:text-base">
        <!-- è¨Šæ¯é¡¯ç¤ºè™• -->
    </div>

    <!-- å³ä¸‹è§’æ§åˆ¶å€ -->
    <div id="controls-area" class="absolute bottom-20 right-4 md:bottom-6 md:right-6 flex flex-col items-end z-20 gap-2">
        <button id="cam-toggle-btn" class="ctrl-btn active" onclick="game.toggleAutoCamera()" title="è‡ªå‹•è·Ÿéš¨è¦–è§’">
            ğŸ“¹
        </button>
        <button id="reset-cam-btn" class="ctrl-btn" onclick="game.resetCameraToCurrentPlayer()" title="é‡ç½®è¦–è§’">
            â†º
        </button>
    </div>

    <!-- åº•éƒ¨æ§åˆ¶å€ -->
    <div class="flex flex-col gap-2 md:gap-4 interactive pb-4 md:pb-8 pointer-events-none items-center w-full">
        <div id="turn-indicator" class="pointer-events-auto text-center text-yellow-400 text-lg md:text-xl font-black drop-shadow-[0_2px_4px_rgba(0,0,0,0.8)] tracking-widest bg-black/40 py-2 rounded-lg px-6 backdrop-blur-sm mb-1">
            ç­‰å¾…å‰æ™‚é–‹å±€...
        </div>
        <div id="hint-text" class="text-center text-yellow-500/80 text-xs md:text-sm font-bold drop-shadow-md tutorial-hint pointer-events-none">
            (å–®æŒ‡è½‰è¦–è§’ â€¢ é»æ“Šé¸ç‰Œ â€¢ é›™æ“Šå‡ºç‰Œ/é»ç‰¹å¯«å‡ºç‰Œ)
        </div>
    </div>
</div>

<!-- é¸å–®åœ–å±¤ -->
<div id="menu-overlay" class="fixed inset-0 bg-[#4a0404]/95 flex items-center justify-center z-50 p-4 md:p-6 text-white text-center backdrop-blur-md">
    <div class="max-w-md w-full border-4 border-[#d4af37] p-6 md:p-8 rounded-3xl bg-[#5a0505] shadow-[0_0_50px_rgba(0,0,0,0.8)] flex flex-col gap-4 md:gap-6">
        <div>
            <h1 class="text-4xl md:text-5xl font-black mb-2 gold-text italic">æ­å–œç™¼è²¡</h1>
            <h2 class="text-xl md:text-2xl font-bold text-yellow-100">å°æ—¥é›™åˆ¶ç«‹é«”éº»å°‡</h2>
        </div>
        
        <div>
            <p class="mb-2 md:mb-3 text-yellow-500/80 font-medium uppercase tracking-widest text-xs">é¸æ“‡æ–°æ˜¥è¦å‰‡</p>
            <div class="flex gap-4 justify-center">
                <button id="rule-jp" onclick="selectRule('JP')" class="flex-1 py-3 rounded-xl border-2 border-white/20 bg-white/5 transition-all font-bold text-sm md:text-base">æ—¥æœ¬éº»å°‡</button>
                <button id="rule-tw" onclick="selectRule('TW')" class="flex-1 py-3 rounded-xl border-2 border-white/20 bg-white/5 transition-all font-bold text-sm md:text-base">è‡ºç£éº»å°‡</button>
            </div>
        </div>

        <div class="text-left">
            <p class="mb-2 md:mb-3 text-yellow-500/80 font-medium uppercase tracking-widest text-xs text-center">æ‹›ç‰ŒéŠç©æ¨¡å¼</p>
            <select id="player-mode" class="w-full p-3 md:p-4 bg-red-900/50 rounded-xl border border-yellow-600/50 text-base md:text-lg appearance-none text-center font-bold text-yellow-100 focus:outline-none focus:border-yellow-400 transition-colors">
                <option value="1h3c">1 ä½ç©å®¶ + 3 ä½é›»è…¦</option>
                <option value="3h1c" selected>3 ä½ç©å®¶ + 1 ä½é›»è…¦</option>
                <option value="4h">4 ä½çœŸäººå°æˆ°</option>
                <option value="2h2c">2 ä½ç©å®¶ + 2 ä½é›»è…¦</option>
            </select>
        </div>

        <button onclick="startGame()" class="w-full bg-gradient-to-r from-red-600 to-red-700 hover:from-red-500 hover:to-red-600 text-white py-4 md:py-5 rounded-2xl font-black text-2xl md:text-3xl shadow-[0_0_40px_rgba(212,175,55,0.4)] border-b-8 border-red-900 active:border-b-0 active:translate-y-2 transition-all">
            é–‹ å±€ è´ ç´… åŒ… <span class="text-sm block font-normal text-yellow-300 mt-1">(è²»ç”¨: 100 ä»£å¹£)</span>
        </button>
        <p class="text-xs text-yellow-600">â€» éŸ³æ¨‚å°‡æ–¼é–‹å±€å¾Œè‡ªå‹•æ’­æ”¾ â€»</p>
    </div>
</div>

<div id="result-overlay" class="fixed inset-0 hidden items-center justify-center bg-black/90 z-[100] p-6">
    <div class="max-w-sm w-full bg-red-950 border-4 border-yellow-500 rounded-3xl p-8 text-center text-white">
        <h2 class="text-4xl font-black text-yellow-400 mb-4" id="result-title">å¤§å‰å¤§åˆ©ï¼</h2>
        <div class="text-xl mb-6" id="result-winner"></div>
        <div class="flex flex-wrap justify-center gap-1 text-3xl mb-6 p-4 rounded-xl bg-white/10" id="result-hand"></div>
        <div class="text-2xl font-bold text-yellow-300 mb-8" id="result-coins"></div>
        <button onclick="location.reload()" class="btn-festive w-full py-4 text-xl">å†é–‹ä¸€å±€</button>
    </div>
</div>

<script>
/**
 * éº»å°‡æ•¸æ“šå®šç¾©
 */
const TILE_EMOJI = {
    'M1':'ğŸ€‡','M2':'ğŸ€ˆ','M3':'ğŸ€‰','M4':'ğŸ€Š','M5':'ğŸ€‹','M6':'ğŸ€Œ','M7':'ğŸ€','M8':'ğŸ€','M9':'ğŸ€',
    'P1':'ğŸ€™','P2':'ğŸ€š','P3':'ğŸ€›','P4':'ğŸ€œ','P5':'ğŸ€','P6':'ğŸ€','P7':'ğŸ€Ÿ','P8':'ğŸ€ ','P9':'ğŸ€¡',
    'S1':'ğŸ€','S2':'ğŸ€‘','S3':'ğŸ€’','S4':'ğŸ€“','S5':'ğŸ€”','S6':'ğŸ€•','S7':'ğŸ€–','S8':'ğŸ€—','S9':'ğŸ€˜',
    'Z1':'ğŸ€€','Z2':'ğŸ€','Z3':'ğŸ€‚','Z4':'ğŸ€ƒ','Z5':'ğŸ€†','Z6':'ğŸ€…','Z7':'ğŸ€„',
    'F1':'ğŸŒ¸','F2':'ğŸŒ¿','F3':'ğŸ‹','F4':'ğŸŒ¼','F5':'â˜€ï¸','F6':'ğŸŒ¬ï¸','F7':'ğŸ‚','F8':'â„ï¸'
};

class MahjongGame {
    constructor() {
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.controls = null;
        this.rule = 'TW';
        this.playerModes = '3h1c';
        this.hands = [[], [], [], []];
        this.melds = [[], [], [], []]; 
        this.discards = [[], [], [], []]; 
        this.flowers = [[], [], [], []]; 
        this.wall = [];
        this.turn = 0;
        this.scores = [0,0,0,0];
        this.credits = 10000; // åˆå§‹ä»£å¹£
        this.tilesObjects = [];
        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();
        this.selectedTile = null; 
        this.labelsGroup = new THREE.Group();
        this.pointerDownTime = 0;
        this.pointerDownPos = new THREE.Vector2();
        
        this.isInitialized = false;
        this.isGameActive = false;
        this.autoDiscardTimeout = null;
        this.waitingForAction = false;
        this.currentActionContext = null; 

        this.autoCamera = true;
        this.baseCameraPositions = [
            { pos: new THREE.Vector3(0, 24, 18), target: new THREE.Vector3(0, -3, 2) },    // P0
            { pos: new THREE.Vector3(18, 24, 0), target: new THREE.Vector3(2, -3, 0) },    // P1
            { pos: new THREE.Vector3(0, 24, -18), target: new THREE.Vector3(0, -3, -2) },  // P2
            { pos: new THREE.Vector3(-18, 24, 0), target: new THREE.Vector3(-2, -3, 0) }   // P3
        ];
    }

    init() {
        if (this.isInitialized) return;

        const container = document.getElementById('game-container');
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x2d0a0a);

        this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.shadowMap.enabled = true;
        container.appendChild(this.renderer.domElement);

        this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        this.controls.maxPolarAngle = Math.PI / 2.1;
        this.controls.minDistance = 10;
        this.controls.maxDistance = 80;

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        this.scene.add(ambientLight);
        const spotLight = new THREE.SpotLight(0xffffff, 0.6);
        spotLight.position.set(0, 40, 0);
        spotLight.castShadow = true;
        this.scene.add(spotLight);

        const tableGeo = new THREE.BoxGeometry(24, 1, 24); 
        const tableMat = new THREE.MeshPhongMaterial({ color: 0x8b0000 });
        const table = new THREE.Mesh(tableGeo, tableMat);
        table.position.y = -1;
        table.receiveShadow = true;
        this.scene.add(table);

        const frameGeo = new THREE.BoxGeometry(25, 0.8, 25);
        const frameMat = new THREE.MeshPhongMaterial({ color: 0xd4af37 });
        const frame = new THREE.Mesh(frameGeo, frameMat);
        frame.position.y = -1.1;
        this.scene.add(frame);
        
        this.scene.add(this.labelsGroup);

        window.addEventListener('resize', () => this.onResize());
        container.addEventListener('pointerdown', (e) => this.onPointerDown(e));
        container.addEventListener('pointerup', (e) => this.onPointerUp(e));

        this.resetCameraToCurrentPlayer(); 
        this.animate();
        this.isInitialized = true;
        this.updateCreditUI();
    }

    getResponsiveCameraPosition(basePos) {
        const aspect = window.innerWidth / window.innerHeight;
        const newPos = basePos.clone();
        
        if (aspect < 1) {
            const zoomFactor = 1.0 + (1.0 - aspect) * 1.5; 
            newPos.multiplyScalar(zoomFactor);
            if (newPos.y > 60) newPos.setLength(60);
        }
        return newPos;
    }

    resetCameraToCurrentPlayer() {
        const currentId = this.turn % 4;
        const baseConfig = this.baseCameraPositions[currentId];
        const targetPos = this.getResponsiveCameraPosition(baseConfig.pos);
        
        new TWEEN.Tween(this.camera.position)
            .to(targetPos, 1000)
            .easing(TWEEN.Easing.Cubic.Out)
            .start();
            
        new TWEEN.Tween(this.controls.target)
            .to(baseConfig.target, 1000)
            .easing(TWEEN.Easing.Cubic.Out)
            .start();
    }

    toggleAutoCamera() {
        this.autoCamera = !this.autoCamera;
        const btn = document.getElementById('cam-toggle-btn');
        if(this.autoCamera) {
            btn.classList.add('active');
            this.resetCameraToCurrentPlayer();
        } else {
            btn.classList.remove('active');
        }
    }

    onResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    }

    isComputer(playerId) {
        const m = this.playerModes;
        if (m === '1h3c') return playerId !== 0;
        if (m === '3h1c') return playerId === 3;
        if (m === '2h2c') return playerId >= 2;
        if (m === '4h') return false;
        return true;
    }

    setupGame(rule, mode) {
        if (this.credits < 100) {
            alert("ä»£å¹£ä¸è¶³ï¼è«‹é‡æ–°æ•´ç†é é¢ä»¥é‡ç½®ä»£å¹£ã€‚");
            game.endGame();
            return;
        }
        this.updateCredits(-100); // æ‰£é™¤é–‹å±€è²»

        this.isGameActive = true;
        this.rule = rule;
        this.playerModes = mode;
        this.scores = rule === 'JP' ? [25000, 25000, 25000, 25000] : [1000, 1000, 1000, 1000];
        this.wall = [];
        this.turn = 0; 
        this.waitingForAction = false;
        
        ['M','P','S'].forEach(suit => {
            for(let i=1; i<=9; i++) for(let k=0; k<4; k++) this.wall.push(suit + i);
        });
        for(let i=1; i<=7; i++) for(let k=0; k<4; k++) this.wall.push('Z' + i);
        if(rule === 'TW') {
            for(let i=1; i<=8; i++) this.wall.push('F' + i);
        }
        
        for(let i = this.wall.length - 1; i > 0; i--) {
            const seed = (Date.now() % 100) / 100; 
            const j = Math.floor((Math.random() + seed) % 1 * (i + 1));
            [this.wall[i], this.wall[j]] = [this.wall[j], this.wall[i]];
        }

        const handSize = rule === 'JP' ? 13 : 16;
        for(let p=0; p<4; p++) {
            this.hands[p] = this.wall.splice(0, handSize);
            this.flowers[p] = [];
            this.discards[p] = [];
            this.melds[p] = [];
        }

        if (rule === 'TW') {
            this.handleFlowerReplacement();
        }

        for(let p=0; p<4; p++) {
            this.hands[p].sort();
        }

        this.controls.enableRotate = true; 
        if (mode === '1h3c') {
            this.controls.minAzimuthAngle = -Math.PI / 4; 
            this.controls.maxAzimuthAngle = Math.PI / 4;  
            document.getElementById('controls-area').classList.add('hidden-ctrl');
            document.getElementById('hint-text').innerText = "(å–®æŒ‡å¾®èª¿è¦–è§’ â€¢ é»æ“Šé¸ç‰Œ â€¢ é›™æ“Šå‡ºç‰Œ/é»ç‰¹å¯«)";
        } else {
            this.controls.minAzimuthAngle = -Infinity;
            this.controls.maxAzimuthAngle = Infinity;
            document.getElementById('controls-area').classList.remove('hidden-ctrl');
            document.getElementById('hint-text').innerText = "(å–®æŒ‡è½‰è¦–è§’ â€¢ é»æ“Šé¸ç‰Œ â€¢ é›™æ“Šå‡ºç‰Œ/é»ç‰¹å¯«)";
        }

        this.createPlayerLabels();
        this.updateUI();
        this.renderTiles();
        
        this.turn = 0; 
        this.resetCameraToCurrentPlayer(); 
        this.nextTurn();
        this.surpriseEffect("ğŸ§§ ç¥ä½ é–‹å¼µå¤§å‰ï¼");
    }

    updateCredits(amount) {
        this.credits += amount;
        this.updateCreditUI();
        
        if (amount < 0) {
            // é¡¯ç¤ºæ‰£æ¬¾å‹•ç•«
            const el = document.createElement('div');
            el.innerText = amount;
            el.className = 'deduct-anim';
            el.style.left = '80px';
            el.style.top = '10px';
            document.getElementById('game-info').appendChild(el);
            setTimeout(() => el.remove(), 1000);
        }
    }

    updateCreditUI() {
        document.getElementById('credit-count').innerText = this.credits;
    }

    handleFlowerReplacement() {
        let hasFlower = true;
        while(hasFlower) {
            hasFlower = false;
            for(let p=0; p<4; p++) {
                const flowerIndices = [];
                this.hands[p].forEach((code, idx) => {
                    if(code.startsWith('F')) flowerIndices.push(idx);
                });

                if (flowerIndices.length > 0) {
                    hasFlower = true;
                    flowerIndices.sort((a,b) => b-a);
                    
                    flowerIndices.forEach(idx => {
                        const fTile = this.hands[p].splice(idx, 1)[0];
                        this.flowers[p].push(fTile); 
                        if(this.wall.length > 0) {
                            const newTile = this.wall.pop();
                            this.hands[p].push(newTile);
                        }
                    });
                }
            }
        }
    }

    endGame() {
        this.isGameActive = false;
        if (this.autoDiscardTimeout) {
            clearTimeout(this.autoDiscardTimeout);
            this.autoDiscardTimeout = null;
        }
        document.getElementById('menu-overlay').style.display = 'flex';
        this.tilesObjects.forEach(obj => this.scene.remove(obj));
        this.tilesObjects = [];
    }

    createPlayerLabels() {
        while(this.labelsGroup.children.length > 0) this.labelsGroup.remove(this.labelsGroup.children[0]); 

        const positions = [
            { x: 0, z: 13, ry: 0 },          
            { x: 13, z: 0, ry: Math.PI/2 }, 
            { x: 0, z: -13, ry: Math.PI },  
            { x: -13, z: 0, ry: -Math.PI/2 } 
        ];

        for(let i=0; i<4; i++) {
            const isComp = this.isComputer(i);
            const text = isComp ? `ğŸ’» é›»è…¦ ${i}` : `ğŸ‘¤ ç©å®¶ ${i+1}`;
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 256; canvas.height = 64;
            
            ctx.fillStyle = isComp ? 'rgba(50, 50, 50, 0.9)' : 'rgba(200, 0, 0, 0.9)';
            ctx.strokeStyle = '#d4af37';
            ctx.lineWidth = 4;
            ctx.beginPath(); ctx.roundRect(4, 4, 248, 56, 10); ctx.fill(); ctx.stroke();

            ctx.fillStyle = '#fff'; ctx.font = 'bold 36px "Microsoft JhengHei"';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(text, 128, 32);

            const texture = new THREE.CanvasTexture(canvas);
            const mat = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide });
            const geo = new THREE.PlaneGeometry(5, 1.25);
            const mesh = new THREE.Mesh(geo, mat);
            
            mesh.position.set(positions[i].x, 0.5, positions[i].z);
            mesh.rotation.x = -Math.PI/2; 
            mesh.rotation.z = positions[i].ry; 
            this.labelsGroup.add(mesh);
        }
    }

    renderTiles() {
        this.tilesObjects.forEach(obj => this.scene.remove(obj));
        this.tilesObjects = [];
        if(this.selectedTile) { this.hidePreview(); this.selectedTile = null; }

        const tW = 0.85, tH = 1.25, tD = 0.55;
        const handSize = this.rule === 'JP' ? 13 : 16;

        for(let p=0; p<4; p++) {
            const hand = this.hands[p];
            const hasDrawnTile = hand.length > handSize + (this.melds[p].length * 3) % 3; 
            const baseLen = hasDrawnTile ? hand.length - 1 : hand.length;
            const meldOffset = this.melds[p].length * (3 * tW * 1.02 + 0.2); 
            const handOffset = (baseLen * tW) / 2;
            
            hand.forEach((tileCode, i) => {
                const tile = this.createTileMesh(tW, tH, tD);
                let x = 0, y = 0, z = 0, rotY = 0;
                const dist = 9.5; 

                let iPos = (i * tW * 1.02) - handOffset - (meldOffset/2); 
                if (hasDrawnTile && i === hand.length - 1) {
                    iPos += 0.4; // æ‘¸ç‰Œé–“éš”
                }

                if(p === 0) { x = iPos; z = dist; rotY = 0; }
                else if(p === 1) { x = dist; z = iPos; rotY = Math.PI/2; } 
                else if(p === 2) { x = -iPos; z = -dist; rotY = Math.PI; } 
                else if(p === 3) { x = -dist; z = -iPos; rotY = -Math.PI/2; }

                const isHuman = !this.isComputer(p);
                if (isHuman) {
                    this.addLabelToTile(tile, TILE_EMOJI[tileCode], tileCode);
                }

                tile.position.set(x, tH/2 + y, z);
                tile.rotation.set(0, rotY, 0); 
                
                tile.userData = { index: i, owner: p, code: tileCode, type: 'hand' };
                tile.castShadow = true;
                this.scene.add(tile);
                this.tilesObjects.push(tile);
            });

            let meldStartX = (hand.length * tW * 1.02) / 2 - (meldOffset/2) + 0.8; 
            
            this.melds[p].forEach((meldGroup, mIdx) => {
                meldGroup.forEach((tileCode, tIdx) => {
                    const tile = this.createTileMesh(tW, tH, tD);
                    this.addLabelToTile(tile, TILE_EMOJI[tileCode], tileCode);
                    
                    let x=0, z=0, rotY=0;
                    const dist = 9.5;
                    const mPos = meldStartX + (mIdx * 3 + tIdx) * (tW * 1.02) + (mIdx * 0.2); 

                    if(p === 0) { x = mPos; z = dist; rotY = 0; }
                    else if(p === 1) { x = dist; z = mPos; rotY = Math.PI/2; } 
                    else if(p === 2) { x = -mPos; z = -dist; rotY = Math.PI; } 
                    else if(p === 3) { x = -dist; z = -mPos; rotY = -Math.PI/2; }

                    tile.position.set(x, tD/2, z); 
                    tile.rotation.set(-Math.PI/2, 0, rotY + Math.PI); 
                    this.scene.add(tile);
                });
            });
        }

        for(let p=0; p<4; p++) {
            const riverTiles = [...this.flowers[p], ...this.discards[p]];
            const rowSize = 6;
            
            riverTiles.forEach((tileCode, i) => {
                const tile = this.createTileMesh(tW, tH, tD);
                this.addLabelToTile(tile, TILE_EMOJI[tileCode], tileCode);

                let x = 0, z = 0, rotY = 0;
                const row = Math.floor(i / rowSize);
                const col = i % rowSize;
                const startDist = 2.5;
                const tileGap = tW * 1.0;
                const rowGap = tH * 0.9;

                if (p === 0) { x = (col - rowSize/2 + 0.5) * tileGap; z = startDist + row * rowGap; rotY = 0; }
                else if (p === 1) { x = startDist + row * rowGap; z = (col - rowSize/2 + 0.5) * tileGap; rotY = -Math.PI/2; }
                else if (p === 2) { x = -(col - rowSize/2 + 0.5) * tileGap; z = -(startDist + row * rowGap); rotY = Math.PI; }
                else if (p === 3) { x = -(startDist + row * rowGap); z = -(col - rowSize/2 + 0.5) * tileGap; rotY = Math.PI/2; }

                tile.position.set(x, tD/2, z);
                tile.rotation.set(-Math.PI/2, 0, rotY + Math.PI);
                tile.receiveShadow = true;
                this.scene.add(tile);
            });
        }
    }

    createTileMesh(w, h, d) {
        const materials = [
            new THREE.MeshPhongMaterial({ color: 0x228b22 }), 
            new THREE.MeshPhongMaterial({ color: 0x228b22 }), 
            new THREE.MeshPhongMaterial({ color: 0x228b22 }), 
            new THREE.MeshPhongMaterial({ color: 0x228b22 }), 
            new THREE.MeshPhongMaterial({ color: 0xffffff }), 
            new THREE.MeshPhongMaterial({ color: 0x004d00 }) 
        ];
        return new THREE.Mesh(new THREE.BoxGeometry(w, h, d), materials);
    }

    addLabelToTile(mesh, text, code) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 128; canvas.height = 128;
        ctx.fillStyle = '#fff'; ctx.fillRect(0,0,128,128);
        
        let color = "#000";
        if (code) {
            if (code.startsWith('M')) color = "#c00";
            if (code.startsWith('F')) color = "#e60";
            if (code === 'Z6') color = "#080";
        }
        
        ctx.fillStyle = color;
        ctx.font = 'bold 95px serif';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(text, 64, 64);

        const texture = new THREE.CanvasTexture(canvas);
        const labelMat = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
        const labelGeo = new THREE.PlaneGeometry(0.78, 1.18);
        const label = new THREE.Mesh(labelGeo, labelMat);
        label.position.z = 0.276; 
        mesh.add(label);
    }

    nextTurn() {
        if (!this.isGameActive || this.waitingForAction) return;

        const currentId = this.turn % 4;
        const isComp = this.isComputer(currentId);
        const label = isComp ? `é›»è…¦ ${currentId}` : `ç©å®¶ ${currentId + 1}`;
        
        document.getElementById('turn-indicator').innerText = `ğŸ§§ è¼ªåˆ° ${label} äº†`;
        document.getElementById('turn-indicator').className = `text-center text-xl font-black drop-shadow-[0_2px_4px_rgba(0,0,0,0.8)] tracking-widest bg-black/40 py-2 rounded-lg mx-auto px-6 backdrop-blur-sm ${isComp ? 'text-gray-300' : 'text-yellow-400'}`;

        if (this.autoCamera && this.playerModes !== '1h3c') {
            this.resetCameraToCurrentPlayer();
        }

        for(let i=0; i<4; i++) {
            const el = document.getElementById(`p${i}-ui`);
            if(i === currentId) {
                el.classList.add('text-yellow-300', 'font-bold', 'scale-110');
                el.classList.remove('text-gray-400');
            } else {
                el.classList.remove('text-yellow-300', 'font-bold', 'scale-110');
                el.classList.add('text-gray-400');
            }
        }

        if(this.wall.length > 0) {
            const newTile = this.wall.shift();
            // èŠ±ç‰Œæª¢æŸ¥
            if (this.rule === 'TW' && newTile.startsWith('F')) {
                this.handleDrawFlower(currentId, newTile);
            } else {
                this.hands[currentId].push(newTile);
                this.renderTiles();
                this.updateUI();
                
                // --- è‡ªæ‘¸æª¢æŸ¥ (Tsumo Check) ---
                if (!isComp) {
                    if (this.checkWin(this.hands[currentId])) {
                        // äº®èµ·èƒ¡ç‰ŒæŒ‰éˆ•ï¼Œä¸¦ä¸å¼·åˆ¶çµæŸï¼Œå…è¨±éæ°´
                        document.getElementById('action-btns').classList.remove('hidden');
                        const huBtn = document.getElementById('btn-hu');
                        huBtn.classList.add('btn-hu-active');
                        huBtn.disabled = false;
                        huBtn.style.opacity = '1';
                        // ç¦ç”¨å…¶ä»–åƒç¢°æ§“
                        ['chi', 'pon', 'kan', 'skip'].forEach(id => {
                            const b = document.getElementById(`btn-${id}`);
                            if(id === 'skip') { 
                                // å…è¨±éæ°´ (skip) = æ‰“ç‰Œ
                                b.disabled = false; 
                                b.style.opacity = '1';
                                b.innerText = "éæ°´(å‡ºç‰Œ)";
                                b.onclick = () => {
                                    // æ¢å¾©æŒ‰éˆ•ç‹€æ…‹ä¸¦éš±è—
                                    huBtn.classList.remove('btn-hu-active');
                                    document.getElementById('action-btns').classList.add('hidden');
                                    b.innerText = "é";
                                };
                            } else {
                                b.disabled = true; b.style.opacity = '0.3'; 
                            }
                        });
                        
                        this.waitingForAction = true; // æš«åœæµç¨‹ç­‰å¾…ç©å®¶æ±ºå®š
                        // è‡ªæ‘¸ä¸ç”¨ contextï¼Œå› ç‚ºæ˜¯è‡ªå·±çš„ç‰Œ
                        this.currentActionContext = { tile: newTile, from: currentId, type: 'tsumo' };
                    }
                }

                if(isComp && !this.waitingForAction) {
                    this.autoDiscardTimeout = setTimeout(() => this.autoDiscard(currentId), 1500);
                }
            }
        } else {
            this.showMessage("ç‰ŒæŠ½å®Œäº†ï¼Œåœ“åœ“æ»¿æ»¿æµå±€ï¼");
        }
    }

    handleDrawFlower(playerId, flowerTile) {
        this.flowers[playerId].push(flowerTile); 
        this.showMessage(`è£œèŠ±ï¼š${TILE_EMOJI[flowerTile]}`);
        this.renderTiles();

        setTimeout(() => {
            if(this.wall.length > 0) {
                const replacementTile = this.wall.pop(); 
                if (replacementTile.startsWith('F')) {
                    this.handleDrawFlower(playerId, replacementTile);
                } else {
                    this.hands[playerId].push(replacementTile);
                    this.renderTiles();
                    
                    if(this.isComputer(playerId)) {
                        this.autoDiscardTimeout = setTimeout(() => this.autoDiscard(playerId), 1500);
                    }
                }
            } else {
                this.showMessage("ç‰ŒæŠ½å®Œäº†ï¼");
            }
        }, 800);
    }

    autoDiscard(playerId) {
        if (!this.isGameActive) return;
        const idx = Math.floor(Math.random() * this.hands[playerId].length);
        this.discardTile(playerId, idx);
    }

    discardTile(playerId, index) {
        if (!this.isGameActive) return;
        const tile = this.hands[playerId].splice(index, 1)[0];
        this.hands[playerId].sort();
        
        this.discards[playerId].push(tile);
        this.renderTiles();
        
        const label = this.isComputer(playerId) ? `é›»è…¦ ${playerId}` : `ç©å®¶ ${playerId + 1}`;
        this.showFocusTile(tile, label);
        this.hidePreview();

        if (playerId !== 0) { 
            if (!this.isComputer(0)) {
                const actions = this.checkAvailableActions(tile, playerId);
                if (actions.length > 0) {
                    this.triggerPlayerAction(actions, tile, playerId);
                    return; 
                }
            }
        }
        
        this.finishTurn();
    }

    finishTurn() {
        this.turn++;
        this.nextTurn();
    }

    checkAvailableActions(tileCode, discarderId) {
        const p0Hand = this.hands[0];
        const actions = [];
        
        const tempHand = [...p0Hand, tileCode];
        if (this.checkWin(tempHand)) {
            actions.push('hu');
        }

        const sameCount = p0Hand.filter(t => t === tileCode).length;
        if (sameCount >= 2) actions.push('pon');
        if (sameCount >= 3) actions.push('kan');
        
        if (discarderId === 3 && tileCode.match(/[MPS]/)) { 
            const suit = tileCode.charAt(0);
            const num = parseInt(tileCode.charAt(1));
            const handNums = p0Hand.filter(t => t.startsWith(suit)).map(t => parseInt(t.charAt(1)));
            
            const hasLeft = handNums.includes(num-2) && handNums.includes(num-1);
            const hasMiddle = handNums.includes(num-1) && handNums.includes(num+1);
            const hasRight = handNums.includes(num+1) && handNums.includes(num+2);
            
            if (hasLeft || hasMiddle || hasRight) actions.push('chi');
        }
        
        return actions;
    }

    triggerPlayerAction(actions, tileCode, discarderId) {
        this.waitingForAction = true;
        this.currentActionContext = { tile: tileCode, from: discarderId, type: 'ron' };
        
        document.getElementById('action-btns').classList.remove('hidden');
        
        ['chi', 'pon', 'kan', 'hu'].forEach(act => {
            const btn = document.getElementById(`btn-${act}`);
            if (actions.includes(act)) {
                btn.disabled = false;
                btn.style.opacity = '1';
                if(act === 'hu') btn.classList.add('btn-hu-active');
            } else {
                btn.disabled = true;
                btn.style.opacity = '0.3';
                btn.classList.remove('btn-hu-active');
            }
        });
        
        const skipBtn = document.getElementById('btn-skip');
        skipBtn.innerText = "é";
        skipBtn.disabled = false;
        skipBtn.style.opacity = '1';
        skipBtn.onclick = () => game.handlePlayerAction('skip');

        const overlay = document.getElementById('preview-overlay');
        overlay.style.opacity = '1';
    }

    handlePlayerAction(action) {
        document.getElementById('action-btns').classList.add('hidden');
        document.getElementById('btn-hu').classList.remove('btn-hu-active'); 
        document.getElementById('preview-overlay').style.opacity = '0';
        this.waitingForAction = false;
        
        const ctx = this.currentActionContext;

        if (ctx.type === 'tsumo') {
            if (action === 'hu') {
                this.surpriseEffect("ğŸ§§ è‡ªæ‘¸ï¼æ­å–œç™¼è²¡ï¼");
                this.updateCredits(1000); // çå‹µ
                this.endGame();
            }
            return;
        }

        if (action === 'skip') {
            this.showMessage("é");
            this.finishTurn();
            return;
        }

        const tile = ctx.tile;
        const fromPlayer = ctx.from;
        
        this.discards[fromPlayer].pop();
        
        if (action === 'pon' || action === 'chi') {
            this.executeMeld(0, action, tile);
            
            this.turn = 0; 
            this.renderTiles();
            this.updateUI();
            document.getElementById('turn-indicator').innerText = "è«‹å‡ºç‰Œ";
            
        } else if (action === 'kan') {
            this.executeMeld(0, 'kan', tile);
            if(this.wall.length > 0) {
                const newTile = this.wall.pop();
                this.hands[0].push(newTile);
                this.showMessage("æ§“ä¸Šé–‹èŠ±?");
                this.renderTiles();
                this.turn = 0;
            }
        } else if (action === 'hu') {
            this.surpriseEffect("ğŸ§§ èƒ¡å•¦ï¼æ­å–œç™¼è²¡ï¼");
            this.updateCredits(500); // çå‹µ
            this.endGame();
        }
    }

    // æ–°å¢ç¢ºèªå‡ºç‰Œæ–¹æ³• (å¾é è¦½å€é»æ“Šè§¸ç™¼)
    confirmDiscardFromPreview() {
        if (this.selectedTile && !this.waitingForAction && this.isGameActive) {
            const owner = this.selectedTile.userData.owner;
            const index = this.selectedTile.userData.index;
            
            const currentId = this.turn % 4;
            // åªè¦é¸å–çš„ç‰Œæ˜¯ç•¶å‰å›åˆç©å®¶çš„ï¼Œä¸”è©²ç©å®¶ä¸æ˜¯é›»è…¦ï¼Œå°±å…è¨±æ‰“å‡º
            if (owner === currentId && !this.isComputer(owner)) {
                this.discardTile(owner, index);
                this.clearSelection();
            }
        }
    }

    executeMeld(playerId, type, targetTile) {
        const hand = this.hands[playerId];
        const meld = [targetTile]; 
        
        if (type === 'pon') {
            for(let i=0; i<2; i++) {
                const idx = hand.indexOf(targetTile);
                if(idx > -1) {
                    meld.push(hand.splice(idx, 1)[0]);
                }
            }
        } else if (type === 'kan') {
            for(let i=0; i<3; i++) {
                const idx = hand.indexOf(targetTile);
                if(idx > -1) {
                    meld.push(hand.splice(idx, 1)[0]);
                }
            }
        } else if (type === 'chi') {
            const suit = targetTile.charAt(0);
            const num = parseInt(targetTile.charAt(1));
            
            const tryRemove = (n) => {
                const code = suit + n;
                const idx = hand.indexOf(code);
                if (idx > -1) {
                    hand.splice(idx, 1);
                    meld.push(code);
                    return true;
                }
                return false;
            };
            
            if (tryRemove(num-1) && tryRemove(num+1)) {} 
            else if (tryRemove(num-2) && tryRemove(num-1)) {}
            else if (tryRemove(num+1) && tryRemove(num+2)) {}
            
            meld.sort(); 
        }
        
        this.melds[playerId].push(meld);
    }

    showFocusTile(tileCode, playerName) {
        const overlay = document.getElementById('preview-overlay');
        const box = document.getElementById('preview-box');
        const emoji = document.getElementById('preview-emoji');
        const text = document.getElementById('preview-text');
        const sub = document.getElementById('preview-sub');
        const hint = document.getElementById('preview-hint');
        
        emoji.innerText = TILE_EMOJI[tileCode];
        text.innerText = playerName + " æ‰“å‡º";
        sub.innerText = "";
        hint.classList.add('hidden'); // å°æ–¹æ‰“ç‰Œæ™‚ï¼Œä¸èƒ½é»æ“Šé è¦½å‡ºç‰Œ
        box.classList.remove('interactive-preview'); // ç§»é™¤äº’å‹•æ¨£å¼
        
        box.classList.remove('preview-anim');
        void box.offsetWidth;
        box.classList.add('preview-anim');
        overlay.style.opacity = '1';
        
        if (!this.waitingForAction) {
            setTimeout(() => { if(!this.waitingForAction) overlay.style.opacity = '0'; }, 1500);
        }
    }

    showPreview(tileCode) {
        const overlay = document.getElementById('preview-overlay');
        const box = document.getElementById('preview-box');
        const emoji = document.getElementById('preview-emoji');
        const text = document.getElementById('preview-text');
        const sub = document.getElementById('preview-sub');
        const hint = document.getElementById('preview-hint');

        emoji.innerText = TILE_EMOJI[tileCode];
        text.innerText = "å·²é¸å–";
        sub.innerText = "(å†æ¬¡é»æ“Šå‡ºç‰Œ)";
        hint.classList.remove('hidden'); // é¡¯ç¤ºé»æ“Šæç¤º
        box.classList.add('interactive-preview'); // å¢åŠ äº’å‹•æ¨£å¼
        
        box.classList.remove('preview-anim');
        void box.offsetWidth;
        box.classList.add('preview-anim');
        overlay.style.opacity = '1';
    }

    hidePreview() {
        document.getElementById('preview-overlay').style.opacity = '0';
    }

    updateUI() {
        document.getElementById('mode-display').innerText = this.rule === 'JP' ? 'æ—¥æœ¬éº»å°‡' : 'è‡ºç£éº»å°‡';
        document.getElementById('wall-count').innerText = this.wall.length;
        for(let i=0; i<4; i++) {
            document.getElementById(`s${i}`).innerText = this.scores[i];
        }
    }

    showMessage(txt) {
        const box = document.getElementById('msg-box');
        box.innerText = txt;
        box.style.opacity = '1';
        setTimeout(() => box.style.opacity = '0', 2000);
    }

    surpriseEffect(txt) {
        const box = document.getElementById('msg-box');
        box.innerText = txt;
        box.classList.add('surprise-text');
        box.style.opacity = '1';
        setTimeout(() => {
            box.style.opacity = '0';
            box.classList.remove('surprise-text');
        }, 1500);
    }

    onPointerDown(event) {
        this.pointerDownTime = Date.now();
        this.pointerDownPos.set(event.clientX, event.clientY);
    }

    onPointerUp(event) {
        const timeDiff = Date.now() - this.pointerDownTime;
        const distDiff = Math.hypot(event.clientX - this.pointerDownPos.x, event.clientY - this.pointerDownPos.y);
        if (timeDiff < 500 && distDiff < 10) {
            this.handleTap(event.clientX, event.clientY);
        }
    }

    handleTap(clientX, clientY) {
        if (!this.isGameActive || this.waitingForAction) {
            if (this.currentActionContext && this.currentActionContext.type === 'tsumo') {
                // allow
            } else {
                return;
            }
        }

        const currentId = this.turn % 4;
        if (currentId !== 0 && !this.isComputer(currentId)) return; 
        if (this.isComputer(currentId)) return; 

        this.mouse.x = (clientX / window.innerWidth) * 2 - 1;
        this.mouse.y = -(clientY / window.innerHeight) * 2 + 1;

        this.raycaster.setFromCamera(this.mouse, this.camera);
        const intersects = this.raycaster.intersectObjects(this.tilesObjects, true);

        if (intersects.length > 0) {
            let targetObj = intersects[0].object;
            while(targetObj && (!targetObj.userData || targetObj.userData.type !== 'hand')) {
                targetObj = targetObj.parent;
            }

            if(targetObj && targetObj.userData.owner === currentId) {
                this.onTileClick(targetObj, currentId);
            }
        } else {
            this.clearSelection();
        }
    }

    onTileClick(obj, playerId) {
        if (this.selectedTile === obj) {
            this.discardTile(playerId, obj.userData.index);
            this.clearSelection();
            
            if (this.currentActionContext && this.currentActionContext.type === 'tsumo') {
                document.getElementById('action-btns').classList.add('hidden');
                document.getElementById('btn-hu').classList.remove('btn-hu-active');
                this.waitingForAction = false;
                this.currentActionContext = null;
            }

        } else {
            this.clearSelection();
            this.selectedTile = obj;
            
            this.selectedTile.position.y += 0.8; 
            this.selectedTile.scale.set(1.3, 1.3, 1.3);
            
            if (Array.isArray(this.selectedTile.material)) {
                this.selectedTile.material.forEach(m => {
                    if (m.name !== 'highlight') {
                        m.oldEmissive = m.emissive.getHex();
                        m.emissive.set(0x333333); 
                    }
                });
            }

            const outlineGeo = new THREE.BoxGeometry(0.9, 1.3, 0.6);
            const outlineMat = new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.BackSide, transparent: true, opacity: 0.3 });
            const outline = new THREE.Mesh(outlineGeo, outlineMat);
            outline.scale.set(1.05, 1.05, 1.05);
            outline.name = "highlight";
            this.selectedTile.add(outline);

            this.showPreview(obj.userData.code);
        }
    }

    clearSelection() {
        if (this.selectedTile) {
            this.selectedTile.position.y -= 0.8;
            this.selectedTile.scale.set(1, 1, 1);
            
            if (Array.isArray(this.selectedTile.material)) {
                this.selectedTile.material.forEach(m => {
                    if (m.oldEmissive !== undefined) {
                        m.emissive.setHex(m.oldEmissive);
                    } else {
                        m.emissive.set(0x000000);
                    }
                });
            }

            const highlight = this.selectedTile.getObjectByName("highlight");
            if(highlight) this.selectedTile.remove(highlight);
            this.selectedTile = null;
            this.hidePreview();
        }
    }

    checkWin(hand) {
        const pureHand = hand.filter(t => !t.startsWith('F'));
        const tiles = {};
        pureHand.forEach(t => tiles[t] = (tiles[t] || 0) + 1);
        
        const tileCodes = Object.keys(tiles).sort();
        
        let pairCount = 0;
        for (let t in tiles) {
            if (tiles[t] >= 2) pairCount++;
        }
        if (pairCount === 7 && pureHand.length === 14) return true; 
        if (pairCount === 8 && pureHand.length === 16) return true; 

        for (let t of tileCodes) {
            if (tiles[t] >= 2) {
                const tempTiles = { ...tiles };
                tempTiles[t] -= 2; 
                if (tempTiles[t] === 0) delete tempTiles[t];
                
                if (this.canFormMelds(tempTiles)) return true;
            }
        }
        return false;
    }

    canFormMelds(tiles) {
        const keys = Object.keys(tiles).sort();
        if (keys.length === 0) return true; 

        const first = keys[0];
        if (tiles[first] >= 3) {
            const nextTiles = { ...tiles };
            nextTiles[first] -= 3;
            if (nextTiles[first] === 0) delete nextTiles[first];
            if (this.canFormMelds(nextTiles)) return true;
        }

        if (first.match(/^[MPS]/)) {
            const suit = first.charAt(0);
            const num = parseInt(first.charAt(1));
            const t2 = suit + (num + 1);
            const t3 = suit + (num + 2);

            if (tiles[t2] > 0 && tiles[t3] > 0) {
                const nextTiles = { ...tiles };
                nextTiles[first]--;
                nextTiles[t2]--;
                nextTiles[t3]--;
                if (nextTiles[first] === 0) delete nextTiles[first];
                if (nextTiles[t2] === 0) delete nextTiles[t2];
                if (nextTiles[t3] === 0) delete nextTiles[t3];
                if (this.canFormMelds(nextTiles)) return true;
            }
        }

        return false;
    }

    animate() {
        requestAnimationFrame(() => this.animate());
        TWEEN.update(); 
        if(this.controls) this.controls.update();
        this.renderer.render(this.scene, this.camera);
    }
}

let game = new MahjongGame();
let selectedRule = 'TW';

function selectRule(rule) {
    selectedRule = rule;
    const jpBtn = document.getElementById('rule-jp');
    const twBtn = document.getElementById('rule-tw');
    const active = "flex-1 py-3 rounded-xl border-2 border-yellow-400 bg-red-700 font-black shadow-lg";
    const inactive = "flex-1 py-3 rounded-xl border-2 border-white/20 bg-white/5 opacity-60";
    jpBtn.className = rule === 'JP' ? active : inactive;
    twBtn.className = rule === 'TW' ? active : inactive;
}

function startGame() {
    const audio = document.getElementById('bgm');
    audio.volume = 0.5;
    audio.play().catch(e => console.log("éœ€äº’å‹•å¾Œæ‰èƒ½æ’­æ”¾éŸ³æ¨‚"));

    const mode = document.getElementById('player-mode').value;
    document.getElementById('menu-overlay').style.display = 'none';
    game.init(); 
    game.setupGame(selectedRule, mode);
}

function returnToMenu() {
    game.endGame();
}

window.onload = () => selectRule('TW');
</script>

</body>
</html>